---
alwaysApply: true
description: Always use Supabase MCP tools to verify database schema, RLS policies, foreign keys, and data before implementing features
---

# Supabase MCP Development Workflow

## Core Principle
**ALWAYS use Supabase MCP tools to verify database schema, RLS policies, foreign keys, and data alignment before implementing or debugging features.** This prevents column mismatches, permission errors, and broken UI components.

---

## When to Use Supabase MCP

### 1. Before Implementing New Features
- ✅ Check table schemas with `mcp_supabase_list_tables`
- ✅ Verify column names, types, and constraints
- ✅ Check foreign key relationships
- ✅ Verify RLS policies won't block access
- ✅ Test sample queries with actual data

**Example:**
```sql
-- Full schema inspection
SELECT 
  c.table_name, 
  c.column_name, 
  c.data_type,
  c.is_nullable,
  tc.constraint_type
FROM information_schema.columns c
LEFT JOIN information_schema.key_column_usage kcu 
  ON c.table_name = kcu.table_name AND c.column_name = kcu.column_name
LEFT JOIN information_schema.table_constraints tc 
  ON kcu.constraint_name = tc.constraint_name
WHERE c.table_schema = 'public' 
  AND c.table_name IN ('your_tables')
ORDER BY c.table_name, c.ordinal_position;
```

### 2. When Debugging API/Frontend Errors

#### Common Issue Categories:

**A. Column Name Mismatches (42703 errors)**
- Frontend/API assumes wrong column names
- **ALWAYS** verify with:
```sql
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'problematic_table'
ORDER BY ordinal_position;
```

**B. Foreign Key Join Issues**
- Joins return null/empty data
- Check foreign key constraints:
```sql
SELECT 
  tc.table_name, 
  kcu.column_name, 
  ccu.table_name AS foreign_table,
  ccu.column_name AS foreign_column,
  tc.constraint_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu 
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu 
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY' 
  AND tc.table_name = 'your_table';
```

**C. RLS Policy Blocks**
- Data exists but API returns empty
- Verify RLS policies and user roles:
```sql
-- Check if data exists (as admin)
SELECT COUNT(*) FROM your_table WHERE condition;

-- Check RLS policies
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual 
FROM pg_policies 
WHERE tablename = 'your_table';
```

**D. Missing/Empty Data**
```sql
-- Check data existence and distribution
SELECT COUNT(*), status, module_id 
FROM your_table 
GROUP BY status, module_id 
ORDER BY COUNT(*) DESC;
```

### 3. Foreign Key Join Syntax

**❌ Wrong: Over-complex foreign key syntax**
```typescript
.select('student:profiles!tutor_assignments_student_id_fkey(name)')
```

**✅ Correct: Simple foreign key syntax**
```typescript
.select('student:profiles!student_id(id, full_name, email)')
```

**Why?** RLS policies can block complex foreign key references. Use simpler syntax.

### 4. Multi-Select Dialogs & UI Components

When building UI components with checkboxes, dropdowns, or multi-select:

**Checklist:**
- ☐ Import required UI components (`ScrollArea`, `Checkbox`, `Select`, etc.)
- ☐ Initialize state properly (arrays for multi-select, strings for single)
- ☐ Handle "Select All" / "Deselect All" logic
- ☐ Validate selections before API calls
- ☐ Show loading states during operations
- ☐ Display success/error feedback
- ☐ Refresh data after mutations
- ☐ Clean up state when dialog closes

**Example:**
```typescript
// State for multi-select
const [selectedItems, setSelectedItems] = useState<string[]>([])

// Select All toggle
const toggleSelectAll = () => {
  if (selectedItems.length === items.length) {
    setSelectedItems([])
  } else {
    setSelectedItems(items.map(i => i.id))
  }
}

// Bulk operations
const handleBulkAction = async () => {
  const promises = selectedItems.map(id => 
    fetch('/api/endpoint', {
      method: 'POST',
      body: JSON.stringify({ id })
    })
  )
  const results = await Promise.all(promises)
  // Handle results...
}
```

### 5. Dialog/Modal Performance Issues

**Problem:** Dialog loads slowly or freezes
**Solutions:**
- Open dialog first, fetch data in background
- Use loading skeletons while data loads
- Remove excessive console.log statements
- Simplify complex state logic
- Use `position="popper"` for Select dropdowns in dialogs

**Before:**
```typescript
onClick={async () => {
  const data = await fetchData() // User waits
  setData(data)
  setShowDialog(true) // Dialog opens after data loads
}}
```

**After:**
```typescript
onClick={() => {
  setShowDialog(true) // Dialog opens immediately
  fetchData().then(setData) // Data loads in background
}}
```

---

## Common Patterns & Solutions

### Pattern 1: Column Name Verification
❌ **Wrong**: Assuming column names
```typescript
.select('question_title, recommendation')
```

✅ **Correct**: Verify first
```sql
SELECT column_name FROM information_schema.columns 
WHERE table_name IN ('questions', 'recommendations');
```
```typescript
.select('title, recommendation_text') // Use verified names
```

### Pattern 2: Foreign Key Data Returns Empty

**Problem:** Foreign key field returns `null` or `undefined`
**Cause:** RLS policy or wrong foreign key syntax

**Debug:**
```sql
-- Test the join manually
SELECT 
  t1.id,
  t1.foreign_key_id,
  t2.name,
  t2.email
FROM table1 t1
LEFT JOIN table2 t2 ON t2.id = t1.foreign_key_id
WHERE t1.some_condition = 'value'
LIMIT 5;
```

**Fix:**
```typescript
// Simplify foreign key syntax
.select(`
  id,
  foreign_key_id,
  related_table:table2!foreign_key_id(id, name, email)
`)
```

### Pattern 3: Enum Type Validation
❌ **Wrong**: Hardcoding enum values
```typescript
.eq('status', 'completed') // Is it 'completed', 'complete', or 'done'?
```

✅ **Correct**: Check enum values first
```sql
SELECT unnest(enum_range(NULL::your_enum_type));
```

### Pattern 4: Bulk Operations
When creating multiple records:

```typescript
const records = []
for (const item1 of selectedItems1) {
  for (const item2 of selectedItems2) {
    records.push({ item1_id: item1.id, item2_id: item2.id })
  }
}

// Parallel execution with progress feedback
toast.loading(`Creating ${records.length} records...`, { id: 'bulk' })
const promises = records.map(data => 
  fetch('/api/endpoint', { method: 'POST', body: JSON.stringify(data) })
)
const results = await Promise.all(promises)
const failed = results.filter(r => !r.ok)

if (failed.length > 0) {
  toast.error(`${failed.length}/${records.length} failed`, { id: 'bulk' })
} else {
  toast.success(`Created ${records.length} successfully!`, { id: 'bulk' })
}
```

### Pattern 5: State Management in Dialogs
```typescript
// Clean up state on dialog close
<Dialog 
  open={showDialog} 
  onOpenChange={(open) => {
    setShowDialog(open)
    if (!open) {
      // Reset all related state
      setSelectedItems([])
      setSearchQuery('')
      setFilters({})
    }
  }}
>
```

---

## Debugging Workflow

### When a Feature Doesn't Work:

**Step 1: Verify Database Schema**
```typescript
mcp_supabase_list_tables({ project_id: "YOUR_PROJECT_ID" })
```
```sql
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'your_table'
ORDER BY ordinal_position;
```

**Step 2: Check Data Existence**
```sql
SELECT * FROM your_table LIMIT 5;
SELECT COUNT(*) FROM your_table WHERE condition;
```

**Step 3: Test Foreign Key Joins**
```sql
SELECT t1.*, t2.name 
FROM table1 t1
LEFT JOIN table2 t2 ON t2.id = t1.foreign_key_id
LIMIT 5;
```

**Step 4: Verify RLS Policies**
```sql
SELECT * FROM pg_policies WHERE tablename = 'your_table';
```

**Step 5: Check API Logs**
```typescript
mcp_supabase_get_logs({ 
  project_id: "YOUR_PROJECT_ID", 
  service: "api" 
})
```

**Step 6: Run Security/Performance Advisors**
```typescript
mcp_supabase_get_advisors({ 
  project_id: "YOUR_PROJECT_ID", 
  type: "security" 
})
```

---

## UI Component Checklist

When implementing any button, dialog, or interactive component:

### Before Implementation:
- ☐ Check if data exists in database
- ☐ Verify API endpoint returns correct data structure
- ☐ Test with `mcp_supabase_execute_sql` first

### During Implementation:
- ☐ Import all required UI components
- ☐ Initialize state with correct types
- ☐ Add loading states (`isLoading`, `isSaving`, etc.)
- ☐ Handle empty states gracefully
- ☐ Add proper error handling with user feedback
- ☐ Use optimistic UI updates where appropriate

### After Implementation:
- ☐ Test with empty data
- ☐ Test with 1 item
- ☐ Test with many items (100+)
- ☐ Test error scenarios
- ☐ Verify data refreshes after mutations
- ☐ Check for memory leaks (state cleanup)

---

## Quick Reference Commands

### Inspect All Tables
```typescript
mcp_supabase_list_tables({ project_id: "YOUR_PROJECT_ID" })
```

### Check Columns for Multiple Tables
```sql
SELECT table_name, column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'public' 
  AND table_name IN ('table1', 'table2', 'table3')
ORDER BY table_name, ordinal_position;
```

### Verify Foreign Keys
```sql
SELECT 
  tc.table_name,
  kcu.column_name,
  ccu.table_name AS foreign_table,
  ccu.column_name AS foreign_column
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu 
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu 
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
ORDER BY tc.table_name;
```

### Check Data Distribution
```sql
SELECT 
  column1,
  COUNT(*) as total_records,
  COUNT(DISTINCT column2) as unique_values,
  AVG(numeric_column) as avg_value
FROM your_table
GROUP BY column1
ORDER BY total_records DESC;
```

### Test Query Performance
```sql
EXPLAIN ANALYZE
SELECT * FROM your_table WHERE conditions;
```

---

## Remember

> **"Database is the source of truth. Always verify schema, test queries, and check RLS policies before coding."**

### The Golden Rule:
1. **Verify** database schema first
2. **Test** queries in Supabase MCP
3. **Implement** with correct column names
4. **Handle** loading, error, and empty states
5. **Refresh** data after mutations
6. **Clean up** state properly

### When in Doubt:
- Check the database first (not the code)
- Use MCP tools to verify (don't assume)
- Test queries before writing frontend code
- Always handle edge cases (empty, error, loading)